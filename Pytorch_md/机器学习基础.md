---
cover: https://gitee.com/Asimok/picgo/raw/master/img/MacBookPro/20201117103456.jpg
title: 机器学习基础
categories: PyTorch
tags:
  - PyTorch
  - 机器学习
  - 正则化
  - 激活函数
  - 损失函数
  - 优化器
keywords: 'PyTorch,机器学习,正则化,激活函数,损失函数,优化器'
---



# 机器学习基础

## 1. 机器学习的基本内容

- 监督学习
- 无监督学习
- 半监督学习
- 强化学习

## 2. 常用的正则化方法

> - 正则化是解决过拟合的常用方法。
>
> - 正则化是什么呢？
>   - 在机器学习中很多显式的用来减少测试误差的策略，统称为正则化。
> - 正则化的目的是减少泛化误差而不是训练误差。

### 2.1权重正则化

- L2正则化称为：权重衰减(Weight Deacy)

$$
min_\theta\frac{1}{2m}\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})^2+\lambda||W||^2
$$

> $\lambda$：权值衰减率

### 2.2 Dropout 正则化

> - 训练过程中按一定的比例，随机忽略或屏蔽一些神经元。
> - 被随机忽略或屏蔽的神经元在反向传播中也不会有任何的权值更新，在传播过程中产生于L2范数相同的收缩权重效果。
> - 加入Dropout之后，输入特征也会随机清除，所以不会给任何一个输入设置太大的权重。
> - 由于网络模型对神经元特定的权重不那么敏感，反而会增加模型的泛化能力。

- 通常Dropout的丢弃率控制在20%-50%。

  > 太低起不到效果，太高会导致欠拟合。

- 在较大型的网络效果更好，会学到多种独立表征。

- 输入层和隐藏层都使用Dropout。

  > 神经元较少的层，设置keep_prob为1或接近1。
  >
  > 神经元较多的层，设置keep_prob为0.5或更小。

- 增加学习率和冲量

  > 学习率：扩大10-100倍
  >
  > 冲量：提高到0.9-0.99

**对网络的权重值做最大范数正则，可以提升模型性能。**

### 2.3 批量正则化(Batch Normalization)

> 用于隐藏层数据分布不均，导致梯度消失或不起作用的情况。

- BN作用在哪里？
  - BN应该作用在非线性映射之前。
- BN如何使用？
  - 在神经网络训练收敛速度很慢，或者梯度爆炸无法训练的情况下使用。
  - BN可以选择比较大的学习率，它具有快速收敛的特性。
  - BN具有提高网络泛化能力的特性，因此不必使用过拟合中Dropout和L2正则化。

### 2.4 权重初始化

- 一般使用正态分布或均匀分布的初始值。
- nn.init模块中提供了xavier、kaiming等经典的初始化策略。
  - xavier一般用于激活函数是S型，例如sigmod、tanh
  - kaiming适合于ReLU类的权重初始化。

## 3. 选择合适的激活函数

> - 激活函数主要作用是，给神经网络提供非线性建模能力。
>
> - 如果没有激活函数，神经网络智只能处理线性可分的问题。

### 3.1 常用激活函数

| 名称      | 表达式                                            | 导数                                                      | 图形                                                         |
| --------- | ------------------------------------------------- | --------------------------------------------------------- | ------------------------------------------------------------ |
| sigmoid   | $f(x)=\frac{1}{1+e^{-x}}$                         | $f'=f(x)(1-f(x))$                                         | ![](https://gitee.com/Asimok/picgo/raw/master/img/MacBookPro/20201115202913.png) |
| tanh      | $f(x=\frac{1-e^{-2x}}{1+e^{2x}})$                 | $f'e(x)=1-(f(x))^2$                                       | ![png](https://gitee.com/Asimok/picgo/raw/master/img/MacBookPro/20201115202919.png) |
| ReLU      | $f(x)=\max(0,x)$                                  | $ f'(x)=\begin{cases}1 & x\geq 0 \\0 & x\lt0\end{cases}$  | ![png](https://gitee.com/Asimok/picgo/raw/master/img/MacBookPro/20201115202934.png) |
| LeakyReLU | $f(x)=\max(ax,0)$                                 | $ f'(x)=\begin{cases}1 & x\geq 0 \\ax & x\lt0\end{cases}$ | ![png](https://gitee.com/Asimok/picgo/raw/master/img/MacBookPro/20201115202927.png) |
| softmax   | $\sigma_i(z)=\frac{e^{z_i}}{\sum_{j=1}^me^{z_j}}$ |                                                           |                                                              |

- 如何选择激活函数
  - 如果网络层数不多，这几种都可以使用。
  - 网络层数较多时，激活函数的导数大于1将导致梯度爆炸，小于1时，经过多层叠加，根据微积分求导链式法制，导数或者偏导将指数级变小。所以导数为1时最好，**ReLU**正好满足。
- softmax激活函数：
  - $\sum_i\sigma_i(z)=1$，常用于多分类神经网络输出层。
  - softmax激活函数将一个向量进行"归一化"成概率分布的形式。

## 4. 选择合适的损失函数

> 交叉熵：(Cross Entropy)	**分类问题**
>
> - 交叉熵损失(Cross-Entropy Loss)，又称对数似然损失(Log-likelihood Loss)，对数损失。二分类时还可称为逻辑回归损失(Logistic Loss)。
>
> 均方差：(Mean squared error，MSE)	**回归问题**

- 正则化项要加在损失函数后面。
- 损失函数越小说明模型和参数越符合训练样本。

### 4.1 分类问题

- 损失函数一般使用**交叉熵**。

  > 交叉熵反应两个概率分布的距离。

### 4.2 回归问题

- 回归问题预测的不是一个类别，而是一个**任意实数**。神经网络一般只有一个输出节点，即预测值。
- 反映真实值与预测值之间的距离可以用欧式距离表示。所以对回归问题一般使用**均方差**作为损失函数。

均方差定义：
$$
MES=\frac{\sum_{i=1}^n(y_i-y_i')^2}{n}
$$

## 5.选择合适的优化器

- 影响优化的两个因素：**学习率**，**梯度**。

### 5.1 动量算法

- 梯度下降法在遇到平坦或高曲率区域时，学习过程有时很慢。利用动量算法能比较好解决这个问题。

- 动量算法示意图：

<img src="https://gitee.com/Asimok/picgo/raw/master/img/MacBookPro/20201115215631.png" alt="image-20201115215631480" style="zoom:50%;" />

- 动量算法每下降一步都是由前面下降方向的一个累积和当前点的梯度方向组合而成。



- 改进的NGA算法：

  > - 动量算法每一步都要将两个梯度方向（历史梯度、当前梯度）做一个合并再下降。
  >
  > - 先按照历史梯度往前走一小步，按照前面一小步位置的“超前梯度”来做梯度合并，得到了动量算法的一种改进算法，称为Nesterov accelerated gradient 简称 NAG 算法。
  > - 这种预更新方法能防止大幅振荡，不会错过最小值，并对参数更新更加敏感。

<img src="https://gitee.com/Asimok/picgo/raw/master/img/MacBookPro/20201115220311.png" alt="image-20201115220311795" style="zoom:50%;" />

- NAG动量法和经典动量法的差别就在B点和C点梯度的不同。动量法，更多关注梯度下降方法的优化。

### 5.2 AdaGrad算法

- AdaGrad算法是通过参数来调整合适的学习率λ，能独立地自动调整模型参数的学习率，对稀疏参数进行大幅更新和对频繁参数进行小幅更新。

  > Adagrad方法非常适合处理稀疏数据。

特点：

- 随着迭代时间越长，累积梯度r越大，从而学习速率$\fracλ{(δ+\sqrt r)}$随着时间就减小，在接近 目标值时，不会因为学习速率过大而越过极值点。

  > 小参数δ：一般取一个较小值(如$10^{-7}$)，该参数避免分母为0。

- 不同参数之间学习速率不同，因此，与前面固定学习速率相比，不容易在鞍点卡住。

- 如果梯度累积参数r$比较小$，则学习速率会比较大，所以参数迭代的步长就会比较大。 相反，如果梯度累积参数比较大，则学习速率会比较小，所以迭代的步长会比较小。

### 5.3 RMSProp算法

- RMSProp算法修改AdaGrad，为的是在非凸背景下效果更好。
- 针对梯度平方和累计越来越大的问题，RMSProp指数加权的移动平均代替梯度平方和。

### 5.4 Adma算法

- Adam(Adaptive Moment Estimation)本质上是带有动量项的RMSprop，它利用梯度的一阶矩估计和二阶矩估计动态调整每个参数的学习率。
- Adam的优点主要在于经过偏置校正后，每一次迭代学习率都有个确定范围，使得参数比较平稳。

### 5.5总结

- RMSprop，Adadelta和Adam被认为是自适应优化算法，因为它们会自动更新学习率。而使用SGD时，必须手动选择学习率和动量参数，通常会随着时间的推移而降低学习率。
- 可以通过先使用Adam优化算法进行训练，这将大大节省训练时间，且不必担心初始化和参数调整，一旦用Adam训练获得较好的参数后，我们可以切换到SGD +动量优化，以达到最佳性能。